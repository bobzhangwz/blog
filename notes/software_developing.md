# 软件开发

> 软件开发（英语：Software development）是根据用户要求建造出软件系统或者系统中软件部分的一个产品开发的过程。
软件开发是一项包括需求获取、开发规划、需求分析和设计、编程实现、软件测试、版本控制的系统工程。
换句话说，软件开发就是一系列最终构建出软件产品的活动。
软件开发可能包括研究、新的开发工作、修改、复用、重新设计（再工程）、维护，或者任何最终获得软件产品的其他活动

-- 摘录自[wiki](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)

什么是软件，为什么要进行软件开发：
1. 定义：运行在机器上从程序
2. 我们的周围被软件包围着，手机、电器、汽车、玩具...
3. 人类文明发展壮大，追求更高的效率，需要越来越多的软件，软件不断更新

丑陋的软件
1. 难以使用，笨拙难以使用的界面
2. 不可靠，容易崩溃且行为不当
3. 粗制滥造，混乱、粗糙的内部结构，对他们更改昂贵又困难

什么是软件之美
1. 对于用户来说，通过直观、简单的界面呈现出恰当的特性的程序就是美
2. 对于软件设计者来说， 被简单直观的分割，并具有最小内部耦合的内部结构就是美的
3. 对于软件开发人员和管理人员来说，每周取得重大进展，并且生产出无缺陷代码的具有活力的团队就是美的

构建、维护一个没的软件系统所花的时间、金钱要少于丑的系统
新手认为做每件事情必须要快，他们认为美是不实用的。但是做事情过快，他们造成的混乱致使软件僵化，难以理解；最终降低开发速度，使软件昂贵而又脆弱

## 工业革命

第一次工业革命采用水蒸气为动力，实现了生产的机械化。(蒸汽时代)
> 一个起点约于1760年代，一直持续到1830年代至1840年代的历史时期。在这段时间里，人类生产逐渐转向新的制造过程，出现了以机器取代人力、兽力的趋势，以大规模的工厂生产取代个体工场手工生产的一场生产与科技革命。由于机器的发明及运用成为了这个时代的标志，因此历史学家称这个时代为机器时代（the Age of Machines）。马克思主义史家将它视为资本主义工业化的早期历程，即资本主义生产完成了从工坊手工业向机器工业过渡的阶段。

第二次工业革命通过电力实现了大规模生产。(电气时代)
>工厂将生产集中至单独特定的区域，并受专家指导（而并非在家进行生产）。劳动分工使得技术或非技术劳动更具生产效率，使得工业中心的人口迅速增长。钢铁厂，铁路，煤炭，纺织工厂等起着推动性作用。工业与科技的迅速发展刺激了更多产业的发展。就像第一次工业革命，第二次工业革命中支持人口增长，且许多政府（不包括英国）利用关税来保护本国经济。这两次大范围的革命使得：随着科学技术的发展，工人阶级开始受到关注；人数众多、逐渐有专业知识的中产阶级的出现；童工人数下降以及以消费者为基础的物质文化的发展。

第三次工业革命则使用电子和信息技术，实现了生产的自动化。

> 因计算机和电子数据的普及和推广而在各行各业发生的从机械和模拟电路到数字电路的变革。第三次科技革命使传统工业更加机械化、自动化，减少了工作成本，彻底改变了整个社会的运作模式，也创造了电脑工业这一高科技产业，它是人类历史上规模最大、影响最深远的科技革命，至今仍未结束。


## 现代软件开发

软件开发是人的活动，软件开发也是一个摸着石头过河的过程

### 瀑布开发

1975年微软成立到今天，软件开发经历43年；

期初经历过由于没有实践的指导而导致的项目噩梦
1. 进度延期
2. 预算增加
3. 低劣的质量

客户会对我们丧失信心，开发人员更长时间的工作生产处更加低劣的软件产品，感到沮丧

一旦经历了这样的惨败，就会害怕重蹈覆辙，我们会根据过去的经验来规定约束和输出，挑选那些在以前项目中看起来不错的方法，并期望这些方法还会有效。

瀑布方法，巨大和笨重，降低团队的响应能力，使得团队经常构建错误的产品
1. 降低开发效率
2. 进度延期
3. 预算超支

### 敏捷实践

2001年初，看到软件团队陷入瀑布的泥潭，概括出了可以让软件开发团队快速开发、响应变化的价值观和原则。称自己为`敏捷联盟`

敏捷价值观

1. 个体和交互 胜过 过程和工具
2. 可以工作的软件 胜过
3. 客户响应 胜过
4. 响应变化 胜过

原则(11)

## 面向对象

### 招式(Java 面向对象)

[继承](http://www.runoob.com/java/java-inheritance.html)

* 子类拥有父类非private的属性，方法。
* 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
* 子类可以用自己的方式实现父类的方法。
* Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。
* 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。

> 继承关键字
  - extends
  - implements
  - super
  - this
  - final
  - 构造器

[多态](http://www.runoob.com/java/java-polymorphism.html)

* 多态是同一个行为具有多个不同表现形式或形态的能力

多态存在的三个必要条件
* 继承
* 重写(重载)
* 父类引用指向子类对象 `Parent p = new Child();`

[封装](http://www.runoob.com/java/java-encapsulation.html)

* 封装，是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。

### 软件设计的臭味

* 僵化性(Rigidity): 很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的其他改动
* 脆弱性(Frigility): 对系统的改动会导致系统中和改动的无关的许多的地方出现问题
* 牢固性: 设计中包含了对其他系统有用的部分，但是要把这块部分分离出来，需要很大大风险和努力
* 粘滞性： 软件的粘滞性和硬件的粘滞性
  *  当新增一个改动时， 会有很多种改法；但是一些容易（但是会破坏设计），做正确的事情很难
  *  生产环境粘滞性，如果编译时间特别长，开发人员就会尽量少的提交
* 不必要的复杂性：开发人员为预测需求的变化，提前为系统做了优化；但是往往设计变得复杂，难以理解
* 不必要的重复：复制黏贴，有很多的重复；没有通过适当的抽象来消除重复
* 晦涩性：代码难以阅读和理解，随着时间会越来越晦涩

#### 代码的演化（7.3节）

```
void Copy() {
  int c;
  while((c=Rdkbd() != EOF)) {
    print(c);
  }
}
```

总结
1. 发现问题
2. 设计原则去诊断问题
3. 用适当的设计模式去解决问题

### 心法（原则）
#### 1. 单一职责 (SRP)
内聚性：一个类，应该仅有一个引起他变化的原因

什么是职责，理解为变化的原因
如果一个类承担了过多的职责那么我们就称之职责耦合在了一起。
当变化发生时，会收到意想不到的破坏；会导致僵化性和脆弱性

例子 Retangle Drawer（P89）

#### 2. 开放-封闭原则 (OCP)

#### 3. 里氏替代原则 (LSP)
#### 4. 依赖倒置原则 (DIP)
#### 5. 接口隔离原则 (ISP）

### 武功秘籍（各种设计模式）
Strategy模式 和 模板模式


## 推荐书籍

1. 敏捷软件开发
2. 人月神话
3. 人件
4. 重构
5. GoF
